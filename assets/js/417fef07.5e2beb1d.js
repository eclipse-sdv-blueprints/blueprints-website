"use strict";(self.webpackChunkblueprints_website=self.webpackChunkblueprints_website||[]).push([[604],{5788:(e,t,n)=>{n.d(t,{Iu:()=>h,yg:()=>g});var r=n(1504);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=c(n),d=o,g=p["".concat(l,".").concat(d)]||p[d]||u[d]||a;return n?r.createElement(g,i(i({ref:t},h),{},{components:n})):r.createElement(g,i({ref:t},h))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6688:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var r=n(5072),o=(n(1504),n(5788));const a={},i="service-to-signal-blueprint",s={unversionedId:"service-to-signal/README",id:"service-to-signal/README",title:"service-to-signal-blueprint",description:"In this Service-To-Signal Blueprint we show how one can implement a service over Eclipse uProtocol where the interface definition is part of the COVESA uServices. We use the Rust implementation of the Eclipse Zenoh transport of Eclipse uProtocol. The service implementation further relies on the interaction with VSS Signals, brokered in an Eclipse Kuksa Databroker.",source:"@site/docs/service-to-signal/README.md",sourceDirName:"service-to-signal",slug:"/service-to-signal/",permalink:"/docs/service-to-signal/",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"overallSidebar",previous:{title:"Introduction",permalink:"/docs/fleet-management/introduction"},next:{title:"Horn Service Kuksa",permalink:"/docs/service-to-signal/components/horn-service-kuksa/"}},l={},c=[{value:"Components",id:"components",level:2},{value:"Horn Service Implementation",id:"horn-service-implementation",level:3},{value:"Horn Client (App)",id:"horn-client-app",level:3},{value:"Kuksa Databroker",id:"kuksa-databroker",level:3},{value:"Embedded Horn Activator",id:"embedded-horn-activator",level:3},{value:"Software Horn",id:"software-horn",level:3},{value:"Kuksa Zenoh Provider",id:"kuksa-zenoh-provider",level:3},{value:"Zenoh Router",id:"zenoh-router",level:3},{value:"Quick Start",id:"quick-start",level:2},{value:"Configuring the zenoh-kuksa-provider",id:"configuring-the-zenoh-kuksa-provider",level:3},{value:"Optional: Configuring and starting the actuator provider (microcontroller implementation)",id:"optional-configuring-and-starting-the-actuator-provider-microcontroller-implementation",level:3}],h={toc:c},p="wrapper";function u(e){let{components:t,...a}=e;return(0,o.yg)(p,(0,r.c)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"service-to-signal-blueprint"},"service-to-signal-blueprint"),(0,o.yg)("p",null,"In this Service-To-Signal Blueprint we show how one can implement a service over Eclipse uProtocol where the interface definition is part of the COVESA uServices. We use the Rust implementation of the Eclipse Zenoh transport of Eclipse uProtocol. The service implementation further relies on the interaction with VSS Signals, brokered in an Eclipse Kuksa Databroker."),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"Overview of Service to Signal Blueprint",src:n(6868).c,width:"461",height:"641"})),(0,o.yg)("p",null,"In order to apply the requested changes we need a so-called Eclipse Kuksa ",(0,o.yg)("em",{parentName:"p"},"Provider")," to communicate the requested changes from the Kuksa Databroker to the underlying hardware.\nIn many current vehicles this might be done over a CAN-bus.\nSince this blueprint focuses more on future vehicle generations and is intended as a technology showcase, we use Eclipse Zenoh instead.\nWe use the Eclipse Kuksa Zenoh Provider which forwards messages between the gRPC-API of the Eclipse Kuksa Databroker and topics in the Zenoh network concerning the relevant and configurable VSS signals."),(0,o.yg)("p",null,"Translating between the HTTP/2 based gRPC communication and Eclipse Zenoh makes it possible to connect embedded devices like an Arduino or ESP32 which can use the ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/eclipse-zenoh/zenoh-pico"},"PicoZenoh implementation"),".\nIf you do not have such hardware available, there is also the option to use a Zenoh client in software as the ",(0,o.yg)("em",{parentName:"p"},"software horn"),"."),(0,o.yg)("h2",{id:"components"},"Components"),(0,o.yg)("p",null,"In the following, we give a more detailed overview of the different involved components."),(0,o.yg)("h3",{id:"horn-service-implementation"},"Horn Service Implementation"),(0,o.yg)("p",null,"The ",(0,o.yg)("a",{parentName:"p",href:"/docs/service-to-signal/components/horn-service-kuksa/"},"horn service implementation")," provides the interfaces defined in the ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/COVESA/uservices/blob/main/src/main/proto/vehicle/body/horn/v1/horn_service.proto"},"COVESA Horn uService"),".\nThe implementation utilizes the ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/COVESA/vehicle_signal_specification/blob/6024c4b29065b37c074649a1a65396b9d4de9b55/spec/Body/Body.vspec#L65"},(0,o.yg)("inlineCode",{parentName:"a"},"Vehicle.Body.Horn.IsActive")," COVESA VSS Signal")," managed by the Eclipse KUKSA Databroker.\nWe use Eclipse Zenoh as transport for the provided Horn service over Eclipse uProtocol."),(0,o.yg)("h3",{id:"horn-client-app"},"Horn Client (App)"),(0,o.yg)("p",null,"The App is a consumer of the Horn service and triggers the execution of specific Horn sequences through this interface. There is the ",(0,o.yg)("a",{parentName:"p",href:"/docs/service-to-signal/components/horn-client/"},"horn-client")," which interacts with the horn service in a pre-defined way and serves as a basic example of how an app can use the horn service."),(0,o.yg)("h3",{id:"kuksa-databroker"},"Kuksa Databroker"),(0,o.yg)("p",null,"The ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/eclipse-kuksa/kuksa-databroker"},"Kuksa Databroker")," acts as a vehicle abstraction layer and manages the interaction between applications and vehicle signals defined in the Vehicle Signal Specification.\nConsumers of the ",(0,o.yg)("inlineCode",{parentName:"p"},"kuksa.val.v1")," API, implemented by the Kuksa Databroker, can get, subscribe and write to the target or the current value of such a signal within the Kuksa Databroker."),(0,o.yg)("h3",{id:"embedded-horn-activator"},"Embedded Horn Activator"),(0,o.yg)("p",null,"We need one component which actually performs the signaling of the Horn. In the easiest setup this is a small program which writes to the console whenever the VSS signal ",(0,o.yg)("inlineCode",{parentName:"p"},"Vehicle.Body.Horn.IsActive")," is ",(0,o.yg)("inlineCode",{parentName:"p"},"True"),". To make the setup a bit more realisitic we decided to integrate hardware like an ESP32 for which there is the ",(0,o.yg)("a",{parentName:"p",href:"./components/actuator-provider/"},"actuator-provider")),(0,o.yg)("p",null,"These smaller hardware platforms struggle with running a full HTTP/2 based gRPC stack which is one of the reasons to utilize Zenoh with the ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/eclipse-zenoh/zenoh-pico"},"Zenoh-Pico")," implementation as transport here."),(0,o.yg)("h3",{id:"software-horn"},"Software Horn"),(0,o.yg)("p",null,"To allow a quick setup of the overall system and in case you do not have an ESP32 hardware available to run the ",(0,o.yg)("a",{parentName:"p",href:"#embedded-horn-activator"},"embedded horn activator"),", there is an alternative software horn. This components connects to the Zenoh router as well and logs the state of the Horn to the console. Optionally, the software horn can play a sound when the horn is active."),(0,o.yg)("h3",{id:"kuksa-zenoh-provider"},"Kuksa Zenoh Provider"),(0,o.yg)("p",null,"For the integration of the hardware controlling the horn, we use Zenoh as transport.\nSo the ",(0,o.yg)("a",{parentName:"p",href:"#embedded-horn-activator"},"horn actuator provider")," publishes and subscribes on a Zenoh topic which is derived from the respective COVESA VSS signal in the Kuksa Databroker.\nIn the case of the Horn, the topic is ",(0,o.yg)("inlineCode",{parentName:"p"},"Vehicle/Body/Horn/IsActive"),".\nIt is then the responsibility of the Zenoh-Kuksa-Provider to listen to these topics and forward the messages between the Zenoh network and the Kuksa Databroker using gRPC."),(0,o.yg)("h3",{id:"zenoh-router"},"Zenoh Router"),(0,o.yg)("p",null,"The Zenoh router routes message between the ",(0,o.yg)("a",{parentName:"p",href:"#kuksa-zenoh-provider"},"Kuksa-Zenoh-Provider")," and the Horn (",(0,o.yg)("a",{parentName:"p",href:"#embedded-horn-activator"},"Embedded Horn Activator")," or ",(0,o.yg)("a",{parentName:"p",href:"#software-horn"},"Software Horn"),"). We use the upstream available ",(0,o.yg)("a",{parentName:"p",href:"https://zenoh.io/docs/getting-started/quick-test/#run-zenoh-in-docker"},"Docker image")," of the Zenoh router and reference it in the Docker Compose file located in ",(0,o.yg)("inlineCode",{parentName:"p"},"service-to-signal-compose.yaml"),"."),(0,o.yg)("h2",{id:"quick-start"},"Quick Start"),(0,o.yg)("h3",{id:"configuring-the-zenoh-kuksa-provider"},"Configuring the zenoh-kuksa-provider"),(0,o.yg)("ol",null,(0,o.yg)("li",{parentName:"ol"},"Initialize the kuksa-incubation submodule to add the zenoh-kuksa-provider to your components directory:")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"git submodule update --init\n")),(0,o.yg)("p",null,"As an alternative you can pull the service-to-signal repository directly by executing:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"git clone --recurse-submodules https://github.com/eclipse-sdv-blueprints/service-to-signal.git\n")),(0,o.yg)("ol",{start:2},(0,o.yg)("li",{parentName:"ol"},"After that, the easiest way to set up and start the services is by means of using the Docker Compose file in the top\nlevel directory:")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"docker compose -f service-to-signal-compose.yaml up --build --detach\n")),(0,o.yg)("p",null,"This will pull or build (if necessary) the container images, create, and start the required components, namely:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#horn-service-implementation"},"horn-service-kuksa")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#kuksa-databroker"},"Kuksa Databroker")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#kuksa-zenoh-provider"},"Kuksa-Zenoh Provider")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#zenoh-router"},"Zenoh Router")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("a",{parentName:"li",href:"#software-horn"},"Software Horn"))),(0,o.yg)("p",null,"As a result the ",(0,o.yg)("inlineCode",{parentName:"p"},"horn-service-kuksa")," becomes available on port 15000 on the host machine. You can then run the ",(0,o.yg)("a",{parentName:"p",href:"#horn-client-app"},"horn client")," to invoke the ",(0,o.yg)("inlineCode",{parentName:"p"},"horn-service-kuksa"),"."),(0,o.yg)("ol",{start:3},(0,o.yg)("li",{parentName:"ol"},"In ",(0,o.yg)("inlineCode",{parentName:"li"},"components/horn-client/")," run:")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"cargo run\n")),(0,o.yg)("p",null,"For more details read the documentation in the ",(0,o.yg)("a",{parentName:"p",href:"/docs/service-to-signal/components/horn-client/"},"horn client Readme"),"."),(0,o.yg)("p",null,"This requires that you installed the ",(0,o.yg)("a",{parentName:"p",href:"https://rustup.rs"},"Rust toolchain")," on your computer. As an alternative you can umcomment the section for the ",(0,o.yg)("inlineCode",{parentName:"p"},"horn-client")," in the ",(0,o.yg)("inlineCode",{parentName:"p"},"service-to-signal-compose.yaml")," and re-deploy the modified Docker Compose setup."),(0,o.yg)("ol",{start:4},(0,o.yg)("li",{parentName:"ol"},"Check logs for Horn")),(0,o.yg)("p",null,"To see the status of the Horn and check whether the setup worked you can read the logs of the ",(0,o.yg)("inlineCode",{parentName:"p"},"software-horn"),". To do this run:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-bash"},"docker logs software-horn\n")),(0,o.yg)("h3",{id:"optional-configuring-and-starting-the-actuator-provider-microcontroller-implementation"},"Optional: Configuring and starting the actuator provider (microcontroller implementation)"),(0,o.yg)("p",null,"If you have the necessary hardware, you can replace the software-based horn with a\nmicrocontroller-based actuator provider. To configure and build the application for\nthe microcontroller, follow the instructions provided for the\n",(0,o.yg)("a",{parentName:"p",href:"/docs/service-to-signal/components/actuator-provider/"},"actuator-provider"),"."))}u.isMDXComponent=!0},6868:(e,t,n)=>{n.d(t,{c:()=>r});const r=n.p+"assets/images/overview.drawio-e7cdfac15f4b3718b97fda873d9bf86f.png"}}]);